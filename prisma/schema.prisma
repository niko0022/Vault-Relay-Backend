generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id                   String           @id @default(uuid())
  email                String           @unique
  passwordHash         String
  displayName          String?
  username             String?          @unique
  avatarUrl            String?
  bio                  String?
  status               UserStatus       @default(OFFLINE)
  lastSeen             DateTime?
  isVerified           Boolean          @default(false)
  createdAt            DateTime         @default(now())
  updatedAt            DateTime         @updatedAt
  friendCode           String           @unique @default(uuid())
  conversationsA       Conversation[]   @relation("convA")
  conversationsB       Conversation[]   @relation("convB")
  friendshipsReceived  Friendship[]     @relation("friendshipAddressee")
  friendshipsRequested Friendship[]     @relation("friendshipRequester")
  sentMessages         Message[]        @relation("sentMessages")
  receipts             MessageReceipt[]
  participants         Participant[]
  refreshTokens        RefreshToken[]
  identityKey          IdentityKey?
  signedPreKey         SignedPreKey?
  oneTimePreKeys       OneTimePreKey[]
}

model Conversation {
  id             String           @id @default(uuid())
  type           ConversationType @default(DIRECT)
  title          String?
  avatarUrl      String?
  createdAt      DateTime         @default(now())
  updatedAt      DateTime         @updatedAt
  lastMessageId  String?
  participantAId String?
  participantBId String?
  participantA   User?            @relation("convA", fields: [participantAId], references: [id])
  participantB   User?            @relation("convB", fields: [participantBId], references: [id])
  messages       Message[]
  participants   Participant[]

  @@unique([participantAId, participantBId])
  @@index([participantAId])
  @@index([participantBId])
}

model Participant {
  id             String          @id @default(uuid())
  conversationId String
  userId         String
  role           ParticipantRole @default(MEMBER)
  joinedAt       DateTime        @default(now())
  mutedUntil     DateTime?
  unreadCount    Int             @default(0)
  conversation   Conversation    @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  user           User            @relation(fields: [userId], references: [id])

  @@unique([conversationId, userId])
  @@index([userId])
}

model Friendship {
  id          String           @id @default(uuid())
  requesterId String
  addresseeId String
  status      FriendshipStatus @default(PENDING)
  createdAt   DateTime         @default(now())
  updatedAt   DateTime         @updatedAt
  acceptedAt   DateTime?
  addressee    User             @relation("friendshipAddressee", fields: [addresseeId], references: [id])
  requester   User             @relation("friendshipRequester", fields: [requesterId], references: [id])

  @@unique([requesterId, addresseeId])
  @@index([addresseeId])
  @@index([requesterId])
}

model Message {
  id             String             @id @default(uuid())
  conversationId String
  senderId       String
  content        String
  contentType    MessageContentType @default(TEXT)
  replyToId      String?
  editedAt       DateTime?
  deleted        Boolean            @default(false)
  createdAt      DateTime           @default(now())
  attachmentUrl  String?
  conversation   Conversation       @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  replyTo        Message?           @relation("messageReplies", fields: [replyToId], references: [id])
  replies        Message[]          @relation("messageReplies")
  sender         User               @relation("sentMessages", fields: [senderId], references: [id])
  receipts       MessageReceipt[]

  @@index([conversationId, createdAt])
  @@index([senderId])
}

model MessageReceipt {
  id        String   @id @default(uuid())
  messageId String
  userId    String
  readAt    DateTime @default(now())
  message   Message  @relation(fields: [messageId], references: [id])
  user      User     @relation(fields: [userId], references: [id])

  @@unique([messageId, userId])
  @@index([userId])
  @@index([messageId])
}

model RefreshToken {
  id             String         @id @default(uuid())
  userId         String
  tokenHash      String         @unique
  createdAt      DateTime       @default(now())
  lastUsedAt     DateTime?
  expiresAt      DateTime
  revoked        Boolean        @default(false)
  replacedById   String?
  userAgent      String?
  deviceId       String?
  replacedBy     RefreshToken?  @relation("tokenReplacement", fields: [replacedById], references: [id])
  replacedTokens RefreshToken[] @relation("tokenReplacement")
  user           User           @relation(fields: [userId], references: [id])

  @@index([userId])
  @@index([expiresAt])
}

model IdentityKey {
  id             String   @id @default(uuid())
  userId         String   @unique
  registrationId Int      // Signal specific ID
  publicKey      String   // Base64 encoded public key
  createdAt      DateTime @default(now())
  user           User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model SignedPreKey {
  id        String   @id @default(uuid())
  userId    String   @unique
  keyId     Int
  publicKey String   // Base64
  signature String   // Base64
  createdAt DateTime @default(now())
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model OneTimePreKey {
  id        String   @id @default(uuid())
  userId    String
  keyId     Int
  publicKey String   // Base64
  createdAt DateTime @default(now())
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, keyId]) // Ensure keyIds are unique per user
}

enum ConversationType {
  DIRECT
  GROUP
}

enum ParticipantRole {
  MEMBER
  ADMIN
}

enum MessageContentType {
  TEXT
  MARKDOWN
  HTML
  SIGNAL_ENCRYPTED
}

enum FriendshipStatus {
  PENDING
  ACCEPTED
  DECLINED
  BLOCKED
  CANCELLED
}

enum UserStatus {
  ONLINE
  OFFLINE
  AWAY
  DND
}
